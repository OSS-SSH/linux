ftrace.event {
	task.task_newtask {
		filter = "pid < 128"
		enable
	}
	kprobes.vfs_read {
		probes = "vfs_read $arg1 $arg2"
		filter = "common_pid < 200"
		enable
	}
	synthetic.initcall_latency {
		fields = "unsigned long func", "u64 lat"
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> a8fa06cfb065a2e9663fe7ce32162762b5fcef5b
		hist {
			keys = func.sym,lat
			values = lat
			sort = lat
		}
<<<<<<< HEAD
	}
	initcall.initcall_start.hist {
		keys = func;
		var.ts0 = common_timestamp.usecs
	}
	initcall.initcall_finish.hist {
		keys = func
		var.lat = common_timestamp.usecs - $ts0
		onmatch {
			event = initcall.initcall_start
			trace = initcall_latency, func, $lat
		}
=======
		actions = "hist:keys=func.sym,lat:vals=lat:sort=lat"
=======
>>>>>>> a8fa06cfb065a2e9663fe7ce32162762b5fcef5b
	}
	initcall.initcall_start.hist {
		keys = func;
		var.ts0 = common_timestamp.usecs
	}
<<<<<<< HEAD
	initcall.initcall_finish {
		actions = "hist:keys=func:lat=common_timestamp.usecs-$ts0:onmatch(initcall.initcall_start).initcall_latency(func,$lat)"
>>>>>>> d5cf6b5674f37a44bbece21e8ef09dbcf9515554
=======
	initcall.initcall_finish.hist {
		keys = func
		var.lat = common_timestamp.usecs - $ts0
		onmatch {
			event = initcall.initcall_start
			trace = initcall_latency, func, $lat
		}
>>>>>>> a8fa06cfb065a2e9663fe7ce32162762b5fcef5b
	}
}

ftrace.instance {
	foo {
		tracer = "function"
		ftrace.filters = "user_*"
		cpumask = 1
		options = nosym-addr
		buffer_size = 512KB
		trace_clock = mono
		event.signal.signal_deliver.actions=snapshot
	}
	bar {
		tracer = "function"
		ftrace.filters = "kernel_*"
		cpumask = 2
		trace_clock = x86-tsc
	}
}

ftrace.alloc_snapshot

kernel {
	trace_options = sym-addr
	trace_event = "initcall:*"
	trace_buf_size = 1M
	ftrace = function
	ftrace_filter = "vfs*"
}
